---
title: 函数零点 副本
cover: /cover/函数零点 副本.png
date: 2023-11-25 19:13:30.096476
abstracts: 本文主要介绍了函数零点问题的求解方法，包括一次函数、二次函数、三次函数以及一般函数的求解方法。对于已知函数解析式的情况，可以采用解析法或计算法求解；对于未知函数解析式的情况，可以采用二分法、牛顿迭代法、割线法和牛顿下山法等方法求解。本文详细介绍了各种方法的实现和原理，并给出相应的代码示例，为函数零点问题的求解提供了有力的工具。
mathjax: true
categories: 学术科研
tags:
- 函数零点
-  解析解法
-  计算解法
---
# 函数零点 副本

原题目是上述洛谷的题，考察二分算法，但由于有一般性，在此拿来总结。

---

# 一次函数（单调函数）

## 解析解法

若已知一次函数的解析表达式，即已知$y=kx+b\quad(k\ne0)$中的 k 和 b 都已知，则可以之间求得唯一零点：

$$
root=-\frac{b}{k}
$$

## 计算解法

若一次函数在某个区间[a,b]上存在零点，则一定存在一个零点，此时只需要简单的使用二分法就能解决问题，这也是其他问题的基础

<p align="center"><img src="/img/函数零点 副本/KQ4PbHFgPodxJixUzGEcmYZunif.png" ></p>

可以看到，求解一次函数$y=x-1$的零点问题，通过在区间（假设为[-1,4]）内取端点为$l^0$、$r^0$，得到$f(l^0)\cdot f(r^0)<0$，故判断之间必存在一个零点。

取两者中点为 1.5，计算得到$f(l^0)\cdot f(1.5)<0$，故取右端点为 1.5，即$r^1=1.5$。重复上述过程，直至找到零点。

## 精度控制

值得注意的是，在二分求解时，并**不是总能准确地二分到零点**，即可能$f(\frac{l^i+l^j}{2})$永远无法刚好取到零，可能总是一个非常小的数。

一般这个时候，会规定求解精度，如**保留小数点后 n 位**，或是**精确到 0.0001** 等等，意味着比这个精确度还小的根不予考虑。常常的做法就是循环控制条件为 `r-l>=0.0001`，如此，当 r 和 l 距离不到精确度时，继续二分得到的结果将会被舍弃，此时二分就没有必要了。

现给出下列求解代码：

```cpp
double findRoot(double l, double r, function<double(double x)> f, double epsilon)
{
    if (f(l) == 0)
    {
        return l;
    }

    if (f(r) == 0)
    {
        return r;
    }

    while (r - l >= epsilon)
    {
        double mid = (l + r) / 2;
        if (f(mid) == 0)
        {
            return mid;
        }
        else if (f(l) * f(mid) < 0)
        {
            r = mid;
        }
        else
        {
            l = mid;
        }
    }

    return l;
}
```

由此可以引出**零点定理**如下：

如零点定理所示，若一个函数在区间[a,b]上单调，且满足零点定理中的前提条件（`连续`，`f(a)·f(b)<0`），则该函数在区间上有且只有唯一的一个零点，如何用计算方法求得这个零点，是后面问题的基础。

上述的**二分法**是一个不错的方法，在最后将介绍**牛顿迭代法**以及其一系列改进与优化。

---

# 二次函数

## 解析解法

若已知二次函数的解析表达式，即已知$y=ax^2+bx+c\quad(a\ne0)$中的 a、b、c，可以使用求根公式来得到两个根：

$$
\triangle=b^2-4ac(\begin{cases}\triangle<0&,no\,\, real \,\,root\\\triangle=0&,2\,\,equivalent\,\,roots\\\triangle>0&,2\,\,different\,\,roots\end{cases}）
$$

$$
x_1=\frac{-b-\sqrt{\triangle}}{2a},\quad \quad x_2=\frac{-b+\sqrt{\triangle}}{2a}\qquad(x1\le x2)
$$

给出求**解二次方程根**的函数：

```cpp
typedef struct quadraticRoot
{
    double root1, root2;
    quadraticRoot(double x1, double x2) : root1(x1), root2(x2) {}

} qRoot;

qRoot findQuadraticRoot(double a, double b, double c)
{
    double delta = b * b - 4 * a * c;

    if (delta < 0)
    {
        throw "no root!";
    }

    double root1 = (-b - sqrt(delta)) / 2 / a;
    double root2 = (-b + sqrt(delta)) / 2 / a;

    return qRoot(root1, root2);
}
```

## 计算解法

二次函数在某一区间[a,b]上存在零点可以分为两种情况，一种是两个相等的根，一种是两个不等的根，如下图所示：

<p align="center"><img src="/img/函数零点 副本/BaYWb2IMioiqUuxOfOncnKltnlf.png" ></p>

_二次函数的两种情况_

可以见得，无论是求解那种情况的零点（$x_0\,or\,x_1,x_2$），都需要找到对称轴，当为**第一种**情况时（两根相同），**对称轴就是零点**；当为**第二种**情况时，在**对称轴的左右区间**分别**执行**一次函数的零点**搜索**算法即可。

### 对称轴搜索

对称轴的确定其实很简单，只要两个不同点的 y 值相同，那么这两个点就是对称的，对称轴就可以由这两个点的横坐标给出：$\frac{x_1+x_2}{2}$。

那么对于给出的区间[a,b]，当 x 分别为 a 和 b 时，有以下三种关系

1. a=b
2. f(a)=f(b)
3. f(a)≠f(b)

显然需要搜索的是第 3 种情况，而从图中很容易发现，**纵坐标绝对值大的点需要向区间内搜索。**问题在于**搜索步长的确定**——不合适的搜索步长会使得搜索过程中，**无法准确找到两个 y 值相等**的点。

然而目前**没有办法**于各种情况下**确定合适的步长**，故只能将其**转化为**另一种形式的**二分搜索**：

> - 令$g(x)=f(x)-f(a)$,在区间$[\frac{a+b}{2},b]\quad (abs(f(b))>=abs(f(a)))$中寻找零点(唯一)
> - 令$g(x)=f(x)-f(b)$,在区间$[a,\frac{a+b}{2}]\quad (abs(f(a))>=abs(f(b)))$中寻找零点(唯一)

这样搜索到了 g(x)的唯一零点 `root` 后（一定精度范围内），就能够得到对称轴。

于是，对应**两根相同**的情况，**root 就是零点**。

对于**两根相异**的情况，需要分别以**[a,root]**、**[root,b]**为子区间，展开**二分搜索**，继续搜索零点。

~~（注：若是在找到对称点不放心仍可以提高精度二分搜索）~~

```cpp
typedef struct quadraticRoot
{
    double root1, root2;
    quadraticRoot(double x1, double x2) : root1(x1), root2(x2) {}

} qRoot;

qRoot findQuadraticRoot(double l, double r, function<double(double x)> f, double epsilon)
{
    double fl = f(l);
    double fr = f(r);

    if (fl == fr)
    {
        return qRoot(l, r);
    }
    else if (fl < fr)
    {
        auto g = [=](double x) -> double
        { return f(x) - fl; };
        r = findRoot((l + r) / 2, r, g, epsilon);
    }
    else
    {
        auto g = [=](double x) -> double
        { return f(x) - fr; };
        l = findRoot(l, (l + r) / 2, g, epsilon);
    }

    double symmetry = (r + l) / 2;
    double root1 = **findRoot**(l, symmetry, f, epsilon);
    double root2 = **findRoot**(symmetry, r, f, epsilon);
    return qRoot(root1, root2);
}
```

---

# 三次函数

## 解析解法

若已知三次函数的解析表达式，即已知$y=ax^3+bx^2+cx+d\quad(a\ne0)$中的 a、b、c、d，可以通过已知的解析信息来搜索零点

### 求根公式（卡尔丹公式）

卡尔丹的公式的具体推导在此不作赘述，具体看[知乎推导贴](https://zhuanlan.zhihu.com/p/71014482?from_voters_page=true)

##### 转化为特殊型

对于一元三次方程$ax^3+bx^2+cx+d=0\quad(a\ne0)$一定可以转化为下面的特殊形式：

$$
x^3+px+q=0
$$

其中:

$$
p=\frac{3ac-b^2}{3a^2}，q=\frac{2b^3-9abc+27a^2d}{27a^3}
$$

##### 求解特殊型

对于一元三次方程$x^3+px+q=0$，给出其判别式：

$$
\triangle=\frac{q^2}{4}+\dfrac{p^3}{27}
$$

1. 当$\triangle>0$时，方程有一个实根和一对共轭虚根。
2. 当 $\triangle=0$且$pq\ne0$时，方程有一个两重实根和一个单重实根。
3. 当$\triangle<0$ 时，方程有三个互异实根。
4. 当$p=q=0$时，方程有一个三重实根。

**给出一般情况下的求根公式：**

$$
\begin{cases} x_1=&\sqrt[3]{-\dfrac{q}{2}+\sqrt{\dfrac{q^2}{4}+\dfrac{p^3}{27}}}&\quad+&\sqrt[3]{-\dfrac{q}{2}-\sqrt{\dfrac{q^2}{4}+\dfrac{p^3}{27}}}\\ x_2=&ω\sqrt[3]{-\dfrac{q}{2}+\sqrt{\dfrac{q^2}{4}+\dfrac{p^3}{27}}}&\quad+&ω^2\sqrt[3]{-\dfrac{q}{2}-\sqrt{\dfrac{q^2}{4}+\dfrac{p^3}{27}}} \\ x_3=& ω^2\sqrt[3]{-\dfrac{q}{2}+\sqrt{\dfrac{q^2}{4}+\dfrac{p^3}{27}}}&\quad+&ω\sqrt[3]{-\dfrac{q}{2}-\sqrt{\dfrac{q^2}{4}+\dfrac{p^3}{27}}} \end{cases}\qquad,ω=-\frac{1}{2}+\frac{\sqrt{3}}{2}i
$$

可见，计算难度相当大（手算），而用计算机计算，需要**支持复数运算（四则和开方）**

在此给出其适合计算机计算的简便形式：

$$
\triangle=\frac{q^2}{4}+\dfrac{p^3}{27}
$$

$$
u=\sqrt[3]{-\frac{q}{2}+\sqrt{\triangle}}\quad,\quad v=\sqrt[3]{-\frac{q}{2}-\sqrt{\triangle}}\quad,\quadω=-\frac{1}{2}+\frac{\sqrt{3}}{2}i
$$

$$
\begin{cases}x_1=u&+&v\\x_2=ωu&+&ω^2v\\x_3=ω^2u&+&ωv\end{cases}
$$

- [ ] ou_7f6ee51dd49317f10f80a0409adf4dc7 有时间可以实现一下复数类

## 计算解法

假设不知道需要求得零点函数的解析表达式，仅仅能够调用函数的接口 `double f(double x)`。

若是知道在区间内**仅有一个零点**，仍然可以用基本的**二分法**去做，但是若是**不知道**区间内的**零点个数**或者**零点个数多于一个**，则只能采用**暴力搜索**，即以最小精度为步长，扫描整个区间。有时候，这是一份拥有极大计算量的工作。

或是“题目”给出了额外的信息，如上述洛谷题目中给出下述信息：

> 根与根之差的绝对值 ≥1

则扫描步长变为了 1，在长度为 1 的区间内进行二分搜索（精度是 0.01），这样也能够加速搜索。

## 半解析半计算

半解析半计算是对解析与计算的一种折中。在现实中解题（尤其是算法竞赛），没有时间定义复数的运算，而可以看到在卡尔丹公式中，求解所有解一定会涉及到复数的运算（**三重互异根的简便公式不涉及复数运算**）。

因此，**借助解析式给出的关于函数的一些性质**，优化搜索，即为半解析半计算的方式。

三次函数有零点的情况无外乎下面三种：

<p align="center"><img src="/img/函数零点 副本/H6RCbWBdjoZWSZxazFecmnkZnBg.png" ></p>

_三次函数的三种情况_

1. 对于第一种，即$root=x_0$的情况，很简单，按照一次函数进行二分搜索即可
2. 对于第二种，即$root=x_1^1\,or\,x_1^2$的情况，可以看到$x_1^2$是零点也是**驻点**。换言之，只要能够求得该函数的驻点（这种情况一定是两个），就能够确定根的范围，再适用二分搜索即可
3. 对于第三种，即$root=x_2^1\,or\,x_2^2\,or\,x_2^3$，与第二种类似，仍然是求**驻点**。

对于形如$y=ax^3+bx^2+cx+d\quad(a\ne0)$的三次函数

**求导**后其变为二次函数：$y=3ax^2+2bx+c\quad(a\ne0)$（$a_{Ⅱ}=3a_{Ⅲ}\,,\,b_{Ⅱ}=2b_{Ⅲ}$）

如此一来该问题转化为求解上述二次函数的零点问题。而在上述三次函数求解零点中，需要求解驻点的情况中，求导得到的二次函数一定有两个零点。

得到两个驻点$p_0,p_1$后：

对于第**三**种情况，直接分别在**三个区间**$[a,p_0],[p_0,p_1],[p_1,b]$中**二分搜索**

对于第**二**种情况，找到为零点的驻点，再确定搜索的区间，具体的确定方式很多，可以给出以下**分支结构**供参考：

_搜索另一个零点参考流程图_

给出代码如下：

```cpp
typedef struct cubicRoot
{
    double root1, root2, root3;
    cubicRoot(double x1, double x2, double x3) : root1(x1), root2(x2), root3(x3) {}
} cRoot;

cRoot findCubicRoot(double l, double r, function<double(double x)> f, function<double(double x)> fp, double epsilon)
{
    qRoot qR = findQuadraticRoot(l, r, fp, epsilon);
    cRoot cR(0, 0, 0);

    if (f(qR.root1) == 0)
    {
        cR.root1 = cR.root2 = qR.root1;
        cR.root3 = findRoot(qR.root1, r, f, epsilon);
    }
    else if (f(qR.root2) == 0)
    {
        cR.root2 = cR.root3 = qR.root2;
        cR.root3 = findRoot(l, qR.root1, f, epsilon);
    }
    else
    {
        cR.root1 = findRoot(l, qR.root1, f, epsilon);
        cR.root2 = findRoot(qR.root1, qR.root2, f, epsilon);
        cR.root3 = findRoot(qR.root2, r, f, epsilon);
    }
    return cR;
}
```

---

# 一般函数

对于一般函数，只能采用与三次函数类似的解法：暴力扫描

# 补充

## 牛顿迭代法

思想是通过不断作**切线**逼近零点。其算法可以描述如下：

1. 在曲线上选取初始点作切线与 x 轴交于一点 p
2. 在曲线上选取 x=p 的点做切线与 x 轴交于一点 q
3. 令 p=q，重复 2 直到找到零点

下面是图形演示：

_第一次作切线（A)求与 x 轴交点                              第二次作切线（B）求与 x 轴交点_

_第三次作切线（C)求与 x 轴交点                              第四次作切线（D）求与 x 轴交点_

可以看到每次作切线求 x 轴交点，就多与零点逼近一些，这是一种直觉。下面给出数学上通过严格证明的其**收敛**的**充分条件**：

> 若 $f(x)$**二阶可导**，那么在待求的零点$x$周围存在**某一个（充分小）区域**，只要起始点$x_0$位于这个邻近区域内，那么牛顿-拉弗森方法必定收敛。

同时给出其**迭代公式**（具体推导不阐述）：

$$
x_{n+1}=x_{n}-{\frac {f(x_{n})}{f'(x_{n})}}
$$

这里给出基本的牛顿迭代法的代码，初始点的选择是 `(l+r)/2`:

```cpp
double findRoot(double l, double r, function<double(double x)> f, function<double(double x)> fp, double epsilon)
{
    if (f(l) == 0)
    {
        return l;
    }

    if (f(r) == 0)
    {
        return r;
    }

    double x0, x1 = (l + r) / 2;

    do
    {
        x0 = x1;
        x1 = x0 - f(x0) / fp(x0);
    } while (abs(x1 - x0) >= epsilon);

    return x1;
}
```

其收敛速度是[二阶](https://baike.baidu.com/item/%E4%BA%8C%E9%98%B6%E6%94%B6%E6%95%9B/2838248?fr=aladdin)的，但仍然存在至少以下两个缺点：

1. 需要求导数
2. 初始点的选择很重要，一不小心就会不收敛

针对上述两个缺点，对牛顿收敛法作了相关改进。

## 割线法

对导数部分作了改进，无需求导数，改用切线斜率代替导数，即：

$$
f'(x_{n})=\frac{f(x_n)-f(x_{n-1})}{x_n-x_{n-1}}
$$

$$
x_{n+1}=x_{n}-{\frac {x_n-x_{n-1}}{f(x_n)-f(x_{n-1})}}f(x_{n})
$$

其中$x_{n-1}$是上一次的迭代点，这意味着需要两个初始点作为算法的起点（第一个初始点是用来近似导数的）。

下面给出割线法的 C++ 代码，初始点选择的是两个三等分点 `(l + r) / 3`, `(l + r) * 2 / 3`：

```cpp
double findRoot(double l, double r, function<double(double x)> f, double epsilon)
{
    if (f(l) == 0)
    {
        return l;
    }

    if (f(r) == 0)
    {
        return r;
    }

    double x0, x1 = (l + r) / 3, x2 = (l + r) * 2 / 3;

    do
    {
        x0 = x1;
        x1 = x2;
        x2 = x1 - (x1 - x0) * f(x1) / (f(x1) - f(x0));
    } while (abs(x2 - x1) >= epsilon);

    return x1;
}
```

## 牛顿下山法

由于初始点的选取会影响算法的收敛性，故试图使用一种方法来修正迭代过程中非收敛的情况，这就是牛顿下山法。

下面给出下山法的**迭代公式**：

$$
x_{n+1}=x_{n}-\lambda{\frac {f(x_{n})}{f'(x_{n})}}\qquad(\lambda\le1)
$$

这里与普通牛顿迭代法的区别就是$\lambda$的引入，下面介绍下山算法来体会其作用：

1. 取$\lambda=1$，进行一次迭代计算得到$x_{n+1}$
2. 若$|f(x_{n+1})|>=|f(x_n)|$，则转到 3；否则，转到 4
3. $\lambda=\frac{\lambda}{2}$，转到 5
4. n=n+1，转到 5
5. 进行一次迭代计算得到$x_{n+1}$，重复 2，直到找到零点

下面给出下山法的 C++ 代码，基于割线法进行了更改：

```cpp
double findRoot(double l, double r, function<double(double x)> f, double epsilon)
{
    if (f(l) == 0)
    {
        return l;
    }

    if (f(r) == 0)
    {
        return r;
    }

    double x0, x1 = (l + r) / 3, x2 = (l + r) * 2 / 3;

    do
    {
        double lambda = 1;
        x0 = x1;
        x1 = x2;
    pos:
        x2 = x1 - lambda * (x1 - x0) * f(x1) / (f(x1) - f(x0));
        if (abs(f(x2)) >= abs(f(x1)))
        {
            lambda /= 2;
            goto pos;
        }
    } while (abs(x2 - x1) >= epsilon);

    return x1;
}
```
